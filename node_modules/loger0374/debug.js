"use strict";

let hasChalk = false;
let chalklib;
try {
    require.resolve('chalk');
    chalklib = require('chalk');
    hasChalk = true;
} catch {
    hasChalk = false;
}

const EventEmitter = require('events');
const fs = require('fs');

class DebugLogger extends EventEmitter {
    /**
     * Класс DebugLogger.
     * @param {string} prefix - Префикс для сообщений отладки.
     * @param {boolean} isDebug - Флаг для включения/выключения режима отладки.
     * @param {boolean} islog - Флаг для использования console.log вместо console.debug.
     * @param {object} prefixforprefix - Префикс для префикса. Аррей, Array где 1 айтем для начала, и 2 для конца оригинальноо префикса.
     * @param {boolean} chalk - Изпользовать красивый цветной текст или нет.
     */
    constructor(prefix, isDebug = false, islog = true, prefixforprefix = ['[',']'], chalk = hasChalk, options = { customconsole: { out : console.log, debug: console.debug }, logfile: { autocreate: false, path: null } }) {
        super();
        /**
         * @var {boolean} isDebug - Флаг для включения/выключения режима отладки
         */
        if (typeof isDebug === "boolean") this.isDebug = isDebug; else this.isDebug = false;
        /** 
         * @var {boolean} islog - Флаг для использования console.log вместо console.debug
         */
        if (typeof islog === "boolean") this.islog = islog; else this.islog = true;
        /**
         * @var {string} prefix - Префикс для сообщений отладки
         */
        if (typeof prefix === "string") this.prefix = prefix; else this.prefix = "null";
        /**
         * @var {object} prefixforprefix - Array Массив из двух строк, которые будут по бокам обычного префикса.
         */
        if (Array.isArray(prefixforprefix)) this.prefixforprefix = prefixforprefix; else this.prefixforprefix = ['[',']'];    
        /**
         * @var {boolean} chalk - Изпользовать ли цветные тексты.
         */
        if (typeof chalk === "boolean") this.chalk = chalk; else this.chalk = hasChalk;
        /**
         * @var {object} options - Дополнительные опции
         * @property {object} customconsole - Пользовательский консольный объект
         * @property {function} customconsole.out - Функция для вывода сообщений (по умолчанию console.log)
         * @property {function} customconsole.debug - Функция для вывода отладочных сообщений (по умолчанию console.debug)
         * @property {object|null} logfile - Опции для логирования в файл
         * @property {boolean} logfile.autocreate - Автоматически создавать файл, если он не существует
         * @property {string} logfile.path - Путь к файлу для логирования
         */
        this.options = {};
        if (
                (
                    options && typeof options === 'object' &&
                    options.customconsole && typeof options.customconsole === 'object' &&
                    typeof options.customconsole.out === 'function' &&
                    typeof options.customconsole.debug === 'function') && (
                (
                    (options.logfile && typeof options.logfile === 'object') &&
                    (typeof options.logfile.autocreate === 'boolean') &&
                    (typeof options.logfile.path === 'string')
                )
            )
        ) {
            this.options = options;
        } else {
            this.options = { customconsole: { out: console.log, debug: console.debug }, logfile: null };
        }

        /**
         * @var {string|null} logfile - Путь к файлу для логирования
         * Если null, логирование в файл не выполняется.
         */
        this.options.logfile = options.logfile || null;

        this.isfirstlog = true;

        this.on('error', () => {});
        this.on('some', (obj) => {
            if (this.options.logfile && this.options.logfile.path) {
                const line = this._format(obj.prefix, obj.prefixforprefix, obj.level, true, ...obj.args).join(' ');
                this.writeToFile(line);
            }
        });

    }

    writeToFile(message) {
        if (!message) return false;
        if (typeof message !== "string") message = String(message);
        if (!this.options.logfile) return false;
        const path = this.options.logfile.path;
        if (!path) return false;
        let firstlog;
        if (this.isfirstlog) {
            this.isfirstlog = false;
            firstlog = true;
        } else {
            firstlog = false;
        }

        const timestamp = new Date().toLocaleString('ru-RU', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });

        const line = `${timestamp} ${message}\n`;
        const greeting = `---=${timestamp}=---\n`;

        let full = firstlog ? greeting : '';
        full = full+line;

        if (this.options.logfile.autocreate && !fs.existsSync(path)) {
            fs.writeFileSync(path, full);
            return true;
        } else if (fs.existsSync(path)) {
            fs.appendFileSync(path, full);
            return true;
        }
        return false;
    }

    /**
     * (Для внутреннего изпользования)
     * Цветной формат, ПфП1, префикс, ПфП2, Аргументы.
     * @param {object[]} prefixforprefix - ПфП, то что по бокам префикса.
     * @param {string} prefix - Префикс
     * @param {string} level - Уровень логирования (log, warn, error)
     * @param {object|null} customcolors - Кастомные цвета для форматирования.
     * @property {string[]} customcolors.pfp - Цвета для ПфП. Массив из двух строк.
     * @property {string} customcolors.pfp.0 - Цвет для первой части ПфП.
     * @property {string} customcolors.pfp.1 - Цвет для второй части ПфП.
     * @property {string} customcolors.prefix - Цвет для префикса.
     * @property {string} customcolors.args - Цвет для аргументов.
     * @property {string} customcolors.level - Цвет для уровня логирования.
     * @param  {...any} args - Данные.
     * @returns {string} Цветовой текст в формате.
     */
    _colorize(prefixforprefix = ['[',']'], prefix = this.prefix, level = 'log', customcolors = null, ...args) {

        if (!this.chalk || !hasChalk) return [prefixforprefix[0], prefix, prefixforprefix[1], ...args];

        // Дефолтные цвета для уровней
        const defaultColors = {
            log: { pfp: ['gray','gray'], prefix: 'green', args: 'blue', level: 'cyan' },
            warn: { pfp: ['gray','gray'], prefix: 'yellow', args: 'yellow', level: 'yellow' },
            error: { pfp: ['gray','gray'], prefix: 'red', args: 'red', level: 'red' }
        };

        // Выбираем цвета: кастомные или дефолтные
        const colors = customcolors && typeof customcolors === "object" ? {
            pfp: customcolors.pfp || ['gray','gray'],
            prefix: customcolors.prefix || 'green',
            args: customcolors.args || 'blue',
            level: customcolors.level || (defaultColors[level].level ? level : 'log')
        } : defaultColors[level] || defaultColors['log'];

        return [
            chalklib[colors.pfp[0]](prefixforprefix[0]),
            chalklib[colors.prefix](prefix),
            chalklib[colors.prefix](':'),
            chalklib[colors.prefix](level),
            chalklib[colors.pfp[1]](prefixforprefix[1]),
            chalklib[colors.args](...args)
        ];
    }


    /**
     * (Для внутреннего изпользования)
     * Формат, ПфП1, префикс, ПфП2, Аргументы.
     * @param {string} prefix - Префикс
     * @param {object} prefixforprefix - ПфП, то что по бокам префикса.
     * @param {string} level - Уровень логирования (log, warn, error)
     * @param {boolean} nocolor - Не использовать цветной текст. (true - без цвета, false - с цветом)
     * @param  {...any} args - Данные.
     * @returns {string} Цветовой текст в формате.
     */
    _format(prefix = this.prefix, prefixforprefix = ['[',']'], level = 'log', nocolor = false, ...args) {
        let formatted;
        if (this.chalk && hasChalk && !nocolor) {
            formatted = this._colorize(prefixforprefix, prefix, level, null, ...args);
        } else {
            formatted = [prefixforprefix[0], prefix, ':', level, prefixforprefix[1], ...args];
        }
        return formatted;
    }

    /**
     * Функция для логирования отладочной информации
     * @param {string} level - Уровень логирования (log, warn, error)
     * @param {...*} args - Аргументы для логирования
     * @returns {void}
     */
    write(level, ...args) {
        const prefix = this.prefix;
        const prefixforprefix = this.prefixforprefix;
        
        if (this.isDebug) {
            const formatted = this._format(prefix, prefixforprefix, level, false, ...args).join(' ');

            if (this.islog) {
                this.options.customconsole.out(formatted);
            } else {
                this.options.customconsole.debug(formatted);
            }
        }

        const eventObj = { level, prefix, args, prefixforprefix };

        this.emit(level, eventObj);
        this.emit('some', eventObj);
    }

    /**
     * Функция для логирования отладочной информации с уровнем "log" (осталось для совместимости)
     * @param {...*} args - Аргументы для логирования
     * @returns {void}
     */
    logDebug(...args) {
        this.write("log", ...args); // Вызываем функцию write с уровнем "log"
    }

    /**
     * Функция для логирования отладочной информации с уровнем "log"
     * @param {...*} args - Аргументы для логирования
     * @returns {void}
     */
    log(...args) {
        this.write("log", ...args); // Вызываем функцию write с уровнем "log"
    }

    /**
     * Функция для логирования отладочной информации с уровнем "warn"
     * @param {...*} args - Аргументы для логирования
     * @returns {void}
     */
    warn(...args) {
        this.write("warn", ...args); // Вызываем функцию write с уровнем "warn"
    }

    /**
     * Функция для логирования отладочной информации с уровнем "error"
     * @param {...*} args - Аргументы для логирования
     * @returns {void}
     */
    error(...args) {
        this.write("error", ...args); // Вызываем функцию write с уровнем "error"
    }

    /** 
     * Функция для установки режима отладки и использования console.log
     * @param {boolean} debugMode - Включить или выключить режим отладки
     * @param {boolean} useLog - Использовать console.log вместо console.debug
     * @param {boolean} chalk - Изпользовать ли цветной текст или нет
     */
    setDebugMode(debugMode, useLog = true, chalk = this.chalk) { // лог по умолчанию, потому что мне так удобнее
        this.chalk = chalk
        this.isDebug = debugMode; // Устанавливаем режим отладки
        this.islog = useLog; // Устанавливаем использование console.log
    }
}

// Экспортируем класс DebugLogger
module.exports = DebugLogger;
module.exports.DebugLogger = DebugLogger; // ну чтобы можно было класно короче


// Пример использования класса DebugLogger
if (require.main === module) { // Только если запускаеться напрямую
    const path = require('path'); // Подключаем path для работы с путями
    let test = new DebugLogger('test', true, true, ["[","]"], true, { logfile: { autocreate: true, path: path.join(__dirname, 'test.log')}}); // Создаем экземпляр класса с префиксом 'test', режим отладки включен и используем console.log
    function log() {
        test.error('cum.'); // Логируем сообщение
        test.setDebugMode(false); // Выключаем режим отладки
        test.warn('ето не выведется.'); // Это сообщение не будет выведено
        test.setDebugMode(true, false); // Включаем режим отладки и используем console.debug
        test.log('ето выведется в console.debug.'); // Логируем сообщение
    }
    log(); // тестовая функция
    test = new DebugLogger('говно', true, true, ['1','Какашечка'], false); // создаем новый екземпляр с другими настройками
    log(); // тестовая функция 2
    test = new DebugLogger('кал', true, true, ['Абоба','2'], true); // снова создаем новый екземпляр с другими настройками
    log(); // тестовая функция 3
}